#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

class Graph {
public:
    int V;
    vector<vector<pair<int,int>>> adj;

    Graph(int V) {
        this->V = V;
        adj.resize(V);
    }

    void addEdge(int u, int v, int w) {
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    void BFS(int start) {
        vector<bool> vis(V, false);
        queue<int> q;

        vis[start] = true;
        q.push(start);

        cout << "BFS: ";
        while (!q.empty()) {
            int u = q.front(); q.pop();
            cout << u << " ";

            for (auto &p : adj[u]) {
                int v = p.first;
                if (!vis[v]) {
                    vis[v] = true;
                    q.push(v);
                }
            }
        }
        cout << "\n";
    }

    void DFSUtil(int u, vector<bool> &vis) {
        vis[u] = true;
        cout << u << " ";

        for (auto &p : adj[u]) {
            int v = p.first;
            if (!vis[v])
                DFSUtil(v, vis);
        }
    }

    void DFS(int start) {
        vector<bool> vis(V, false);
        cout << "DFS: ";
        DFSUtil(start, vis);
        cout << "\n";
    }

    int findParent(int u, vector<int> &par) {
        return (par[u] == u) ? u : par[u] = findParent(par[u], par);
    }

    void unionSet(int u, int v, vector<int> &par, vector<int> &rank) {
        u = findParent(u, par);
        v = findParent(v, par);

        if (u != v) {
            if (rank[u] < rank[v]) par[u] = v;
            else if (rank[v] < rank[u]) par[v] = u;
            else par[v] = u, rank[u]++;
        }
    }

    void Kruskal() {
        vector<tuple<int,int,int>> edges;

        for (int u = 0; u < V; u++) {
            for (auto &p : adj[u]) {
                int v = p.first, w = p.second;
                if (u < v) edges.push_back({w, u, v});
            }
        }

        sort(edges.begin(), edges.end());

        vector<int> par(V), rank(V, 0);
        for (int i = 0; i < V; i++) par[i] = i;

        cout << "Kruskal MST:\n";
        int total = 0;

        for (auto &e : edges) {
            int w, u, v;
            tie(w, u, v) = e;

            if (findParent(u, par) != findParent(v, par)) {
                cout << u << " - " << v << " : " << w << "\n";
                total += w;
                unionSet(u, v, par, rank);
            }
        }

        cout << "Total Weight = " << total << "\n";
    }

    void Prim(int start = 0) {
        vector<int> key(V, 1e9), parent(V, -1);
        vector<bool> taken(V, false);
        key[start] = 0;

        for (int i = 0; i < V; i++) {
            int u = -1;

            for (int v = 0; v < V; v++)
                if (!taken[v] && (u == -1 || key[v] < key[u]))
                    u = v;

            taken[u] = true;

            for (auto &p : adj[u]) {
                int v = p.first, w = p.second;

                if (!taken[v] && w < key[v]) {
                    key[v] = w;
                    parent[v] = u;
                }
            }
        }

        cout << "Prim MST:\n";
        int total = 0;

        for (int v = 1; v < V; v++) {
            cout << parent[v] << " - " << v << " : " << key[v] << "\n";
            total += key[v];
        }

        cout << "Total Weight = " << total << "\n";
    }

    void Dijkstra(int start) {
        vector<int> dist(V, 1e9);
        dist[start] = 0;

        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
        pq.push({0, start});

        while (!pq.empty()) {
            auto [d, u] = pq.top();
            pq.pop();

            if (d > dist[u]) continue;

            for (auto &p : adj[u]) {
                int v = p.first, w = p.second;

                if (dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                    pq.push({dist[v], v});
                }
            }
        }

        cout << "Dijkstra Distances:\n";
        for (int i = 0; i < V; i++)
            cout << start << " -> " << i << " = " << dist[i] << "\n";
    }
};

int main() {
    Graph g(6);

    g.addEdge(0, 1, 4);
    g.addEdge(0, 2, 2);
    g.addEdge(1, 2, 5);
    g.addEdge(1, 3, 10);
    g.addEdge(2, 4, 3);
    g.addEdge(4, 3, 4);
    g.addEdge(3, 5, 11);

    g.BFS(0);
    g.DFS(0);
    g.Kruskal();
    g.Prim();
    g.Dijkstra(0);

    return 0;
}
